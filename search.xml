<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Spring Cloud</title>
      <link href="/post/750d7523.html"/>
      <url>/post/750d7523.html</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><p>Spring Cloud 自 2016 年 1 月发布第一个 Angel.SR5 版本，到目前 2020 年 3 月发布 Hoxton.SR3 版本，已经历经了 4 年时间。这 4 年时间里，Spring Cloud 一共发布了 46 个版本，支持的组件数从 5 个增加到 21 个。Spring Cloud 在 2019 年 12 月对外宣布后续 RoadMap：</p><ul><li>下一个版本 Ilford 版本是一个大版本。这个版本基于 Spring Framework 5.3 &amp; Spring Boot 2.4，会在 2020 Q4 左右发布；</li><li>Ilford 版本会删除处于维护模式的项目。目前处于维护模式的 Netflix 大部分项目都会被删除（spring-cloud-netflix Github 项目已经删除了这些维护模式的项目）；</li><li>简化 Spring Cloud 发布列车。后续 IaasS 厂商对应的 Spring Cloud 项目会移出 Spring Cloud 组织，各自单独维护（spring-cloud-azure 一直都是单独维护，spring-cloud-alibaba 孵化在 Spring Cloud 组织，毕业后单独维护）；</li><li>API 重构，会带来重大的改变（Spring Cloud Hoxton 版本新增了 Spring Cloud Circuit Breaker 用于统一熔断操作的编程模型和 Spring Cloud LoadBalanacer 用于处理客户端负载均衡并代替 Netflix Ribbon）。</li></ul><p>这个 RoadMap 可以说是对 Spring Cloud 有着非常大的变化。</p><h3 id="SpringCloud替代实现"><a href="#SpringCloud替代实现" class="headerlink" title="SpringCloud替代实现"></a>SpringCloud替代实现</h3><p><img src="/images/1" alt="img"></p><h3 id="SpringCloud-gt-Alibaba"><a href="#SpringCloud-gt-Alibaba" class="headerlink" title="SpringCloud -&gt; Alibaba"></a>SpringCloud -&gt; Alibaba</h3><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>**<a href="https://github.com/alibaba/Sentinel">Sentinel</a>**：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><p>**<a href="https://github.com/alibaba/Nacos">Nacos</a>**：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p><p>**<a href="https://rocketmq.apache.org/">RocketMQ</a>**：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</p><p>**<a href="https://github.com/apache/dubbo">Dubbo</a>**：Apache Dubbo™ 是一款高性能 Java RPC 框架。</p><p>**<a href="https://github.com/seata/seata">Seata</a>**：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</p><p>**<a href="https://www.aliyun.com/product/acm">Alibaba Cloud ACM</a>**：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</p><p><strong><a href="https://www.aliyun.com/product/oss">Alibaba Cloud OSS</a></strong>: 阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</p><p><strong><a href="https://help.aliyun.com/document_detail/43136.html">Alibaba Cloud SchedulerX</a></strong>: 阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</p><p><strong><a href="https://www.aliyun.com/product/sms">Alibaba Cloud SMS</a></strong>: 覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</p><h2 id="Spring-Cloud技术点"><a href="#Spring-Cloud技术点" class="headerlink" title="Spring Cloud技术点"></a>Spring Cloud技术点</h2><p>Eureka：服务注册与发现，用于服务管理。</p><p>Feign： web调用客户端，能够简化HTTP接口的调用。</p><p>Ribbon：基于客户端的负载均衡。</p><p>Hystrix：熔断降级，防止服务雪崩。</p><p>Zuul：网关路由，提供路由转发、请求过滤、限流降级等功能。</p><p>Config：配置中心，分布式配置管理。</p><p>Sleuth：服务链路追踪</p><p>Admin：健康管理</p><h2 id="服务进化概述"><a href="#服务进化概述" class="headerlink" title="服务进化概述"></a>服务进化概述</h2><ol><li><p>传统服务到微服务进化。</p><blockquote><p>《传统到分布式演进》</p></blockquote></li><li><p>单体应用-&gt; SOA -&gt;微服务（下面讲）</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">课外扩展：</span><br><span class="line">持续集成，持续部署，持续交付。</span><br><span class="line">集成:是指软件个人研发的部分向软件整体部分集成，以便尽早发现个人开发部分的问题；</span><br><span class="line">部署: 是代码尽快向可运行的开发/测试节交付，以便尽早测试；</span><br><span class="line">交付: 是指研发尽快向客户交付，以便尽早发现生产环境中存在的问题。</span><br><span class="line">   如果说等到所有东西都完成了才向下个环节交付，导致所有的问题只能在最后才爆发出来，解决成本巨大甚至无法解决。而所谓的持续，就是说每完成一个完整的部分，就向下个环节交付，发现问题可以马上调整。使问题不会放大到其他部分和后面的环节。</span><br><span class="line">   这种做法的核心思想在于：既然事实上难以做到事先完全了解完整的、正确的需求，那么就干脆一小块一小块的做，并且加快交付的速度和频率，使得交付物尽早在下个环节得到验证。早发现问题早返工。</span><br><span class="line"></span><br><span class="line">上面的3个持续，也都随着微服务的发展而发展，当架构师的同学，可以参考这种方式。</span><br><span class="line"></span><br><span class="line">持续集成的工具，向大家推荐：https://jenkins.io/doc/book/pipeline/</span><br></pre></td></tr></table></figure><h3 id="单体应用"><a href="#单体应用" class="headerlink" title="单体应用"></a>单体应用</h3><ol><li><p>概念：所有功能全部打包在一起。应用大部分是一个war包或jar包。我参与网约车最开始架构是：一个乘客项目中有 用户、订单、消息、地图等功能。随着业务发展，功能增多，这个项目会越来越臃肿。</p></li><li><p>好处：容易开发、测试、部署，适合项目初期试错。</p></li><li><p>坏处：</p><p>​随着项目越来越复杂，团队不断扩大。坏处就显现出来了。</p><ul><li>复杂性高：代码多，十万行，百万行级别。加一个小功能，会带来其他功能的隐患，因为它们在一起。</li><li>技术债务：人员流动，不坏不修，因为不敢修。</li><li>持续部署困难：由于是全量应用，改一个小功能，全部部署，会导致无关的功能暂停使用。编译部署上线耗时长，不敢随便部署，导致部署频率低，进而又导致两次部署之间 功能修改多，越不敢部署，恶性循环。</li><li>可靠性差：某个小问题，比如小功能出现OOM，会导致整个应用崩溃。</li><li>扩展受限：只能整体扩展，无法按照需要进行扩展，  不能根据计算密集型（派单系统）和IO密集型（文件服务） 进行合适的区分。</li><li>阻碍创新：单体应用是以一种技术解决所有问题，不容易引入新技术。但在高速的互联网发展过程中，适应的潮流是：用合适的语言做合适的事情。比如在单体应用中，一个项目用spring MVC，想换成spring boot，切换成本很高，因为有可能10万，百万行代码都要改，而微服务可以轻松切换，因为每个服务，功能简单，代码少。</li></ul></li></ol><h3 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h3><pre><code>   对单体应用的改进：引入SOA（Service-Oriented Architecture）面向服务架构，拆分系统，用服务的流程化来实现业务的灵活性。服务间需要某些方法进行连接，面向接口等，它是一种设计方法，其中包含多个服务， 服务之间通过相互依赖最终提供一系列的功能。一个服务 通常以独立的形式存在于操作系统进程中。各个服务之间 通过网络调用。但是还是需要用些方法来进行服务组合，有可能还是个单体应用。</code></pre><p>所以要引入微服务，是SOA思想的一种具体实践。</p><p>微服务架构 &#x3D; 80%的SOA服务架构思想 + 100%的组件化架构思想</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><h4 id="微服务概况"><a href="#微服务概况" class="headerlink" title="微服务概况"></a>微服务概况</h4><ul><li>无严格定义。</li><li>微服务是一种架构风格，将单体应用划分为小型的服务单元。</li><li>微服务架构是一种使用一系列粒度较小的服务来开发单个应用的方式；每个服务运行在自己的进程中；服务间采用轻量级的方式进行通信(通常是HTTP API)；这些服务是基于业务逻辑和范围，通过自动化部署的机制来独立部署的，并且服务的集中管理应该是最低限度的，即每个服务可以采用不同的编程语言编写，使用不同的数据存储技术。</li><li>英文定义：</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">看这篇文章：</span><br><span class="line">http://www.martinfowler.com/articles/microservices.html</span><br></pre></td></tr></table></figure><ul><li><p>小类比</p><p>合久必分。分开后通信，独立部署，独立存储。</p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">分封制：</span><br><span class="line">服从天子命令：服从服务管理。</span><br><span class="line">有为天子镇守疆土的义务：各自完成各自的一块业务。</span><br><span class="line">随从作战：服务调用。</span><br><span class="line">交纳贡献：分担流量压力。</span><br></pre></td></tr></table></figure><ul><li>段子（中台战略）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Q：大师大师，服务拆多了怎么办？</span><br><span class="line">A：那就再合起来。</span><br><span class="line">Q：那太没面子了。</span><br><span class="line">A：那就说跨过了微服务初级阶段，在做中台（自助建站系统）。</span><br></pre></td></tr></table></figure><h4 id="微服务特性"><a href="#微服务特性" class="headerlink" title="微服务特性"></a>微服务特性</h4><p>独立运行在自己进程中。</p><p>一系列独立服务共同构建起整个系统。</p><p>一个服务只关注自己的独立业务。</p><p>轻量的通信机制RESTful API</p><p>使用不同语言开发</p><p>全自动部署机制</p><h4 id="微服务组件介绍"><a href="#微服务组件介绍" class="headerlink" title="微服务组件介绍"></a>微服务组件介绍</h4><p>不局限与具体的微服务实现技术。</p><ul><li><p>服务注册与发现：服务提供方将己方调用地址注册到服务注册中心，让服务调用方能够方便地找到自己；服务调用方从服务注册中心找到自己需要调用的服务的地址。</p></li><li><p>负载均衡：服务提供方一般以多实例的形式提供服务，负载均衡功能能够让服务调用方连接到合适的服务节点。并且，服务节点选择的过程对服务调用方来说是透明的。</p></li><li><p>服务网关：服务网关是服务调用的唯一入口，可以在这个组件中实现用户鉴权、动态路由、灰度发布、A&#x2F;B测试、负载限流等功能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">灰度发布（又名金丝雀发布）是指在黑与白之间，能够平滑过渡的一种发布方式。在其上可以进行A/B testing，即让一部分用户继续用产品特性A，一部分用户开始用产品特性B，如果用户对B没有什么反对意见，那么逐步扩大范围，把所有用户都迁移到B上面来。灰度发布可以保证整体系统的稳定，在初始灰度的时候就可以发现、调整问题，以保证其影响度。</span><br></pre></td></tr></table></figure></li><li><p>配置中心：将本地化的配置信息(Properties、XML、YAML等形式)注册到配置中心，实现程序包在开发、测试、生产环境中的无差别性，方便程序包的迁移，也是无状态特性。</p></li><li><p>集成框架：微服务组件都以职责单一的程序包对外提供服务，集成框架以配置的形式将所有微服务组件(特别是管理端组件)集成到统一的界面框架下，让用户能够在统一的界面中使用系统。Spring Cloud就是一个集成框架。</p></li><li><p>调用链监控：记录完成一次请求的先后衔接和调用关系，并将这种串行或并行的调用关系展示出来。在系统出错时，可以方便地找到出错点。</p></li><li><p>支撑平台：系统微服务化后，各个业务模块经过拆分变得更加细化，系统的部署、运维、监控等都比单体应用架构更加复杂，这就需要将大部分的工作自动化。现在，Docker等工具可以给微服务架构的部署带来较多的便利，例如持续集成、蓝绿发布、健康检查、性能监控等等。如果没有合适的支撑平台或工具，微服务架构就无法发挥它最大的功效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 蓝绿部署是不停老版本，部署新版本然后进行测试，确认OK，将流量切到新版本，然后老版本同时也升级到新版本。</span><br><span class="line">2. 灰度是选择部分部署新版本，将部分流量引入到新版本，新老版本同时提供服务。等待灰度的版本OK，可全量覆盖老版本。</span><br><span class="line"></span><br><span class="line">灰度是不同版本共存，蓝绿是新旧版本切换，2种模式的出发点不一样。</span><br></pre></td></tr></table></figure></li></ul><h4 id="微服务优点"><a href="#微服务优点" class="headerlink" title="微服务优点"></a>微服务优点</h4><ol><li>独立部署。不依赖其他服务，耦合性低，不用管其他服务的部署对自己的影响。</li><li>易于开发和维护：关注特定业务，所以业务清晰，代码量少，模块变的易开发、易理解、易维护。</li><li>启动块：功能少，代码少，所以启动快，有需要停机维护的服务，不会长时间暂停服务。</li><li>局部修改容易：只需要部署 相应的服务即可，适合敏捷开发。</li><li>技术栈不受限：java，node.js等</li><li>按需伸缩：某个服务受限，可以按需增加内存，cpu等。</li><li>职责专一。专门团队负责专门业务，有利于团队分工。</li><li>代码复用。不需要重复写。底层实现通过接口方式提供。</li><li>便于团队协作：每个团队只需要提供API就行，定义好API后，可以并行开发。</li></ol><h4 id="微服务缺点"><a href="#微服务缺点" class="headerlink" title="微服务缺点"></a>微服务缺点</h4><ol><li><p>分布式固有的复杂性：容错（某个服务宕机），网络延时，调用关系、分布式事务等，都会带来复杂。</p></li><li><p>分布式事务的挑战：每个服务有自己的数据库，有点在于不同服务可以选择适合自身业务的数据库。订单用MySQL，评论用Mongodb等。目前最理想解决方案是：柔性事务的最终一致性。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">刚性事务：遵循ACID原则，强一致性。</span><br><span class="line">柔性事务：遵循BASE理论，最终一致性；与刚性事务不同，柔性事务允许一定时间内，不同节点的数据不一致，但要求最终一致。</span><br><span class="line"></span><br><span class="line">BASE 是 Basically Available(基本可用)、Soft state(软状态)和 Eventually consistent (最终一致性)三个短语的缩写。BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“柔性事务”。</span><br></pre></td></tr></table></figure></li><li><p>接口调整成本高：改一个接口，调用方都要改。</p></li><li><p>测试难度提升：一个接口改变，所有调用方都得测。自动化测试就变的重要了。API文档的管理也尤为重要。推荐：yapi。</p></li><li><p>运维要求高：需要维护 几十 上百个服务。监控变的复杂。并且还要关注多个集群，不像原来单体，一个应用正常运行即可。</p></li><li><p>重复工作：比如java的工具类可以在共享common.jar中，但在多语言下行不通，C++无法直接用java的jar包。</p></li></ol><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p>单一职责原则：关注整个系统功能中单独，有界限的一部分。</p><p>服务自治原则：可以独立开发，测试，构建，部署，运行，与其他服务解耦。</p><p>轻量级通信原则：轻，跨平台，跨语言。REST,AMQP 等。</p><p>粒度把控：与自己实际相结合。 不要追求完美，随业务进化而调整。《淘宝技术这10年》。</p><h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><ol><li><p>Spring Cloud和dubbo组件比较</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dubbo：zookeeper+dubbo+springmvc/springboot</span><br><span class="line">通信方式：rpc</span><br><span class="line">注册中心：zookeeper，nacos</span><br><span class="line">配置中心：diamond（淘宝开发）</span><br><span class="line"></span><br><span class="line">spring cloud：spring+Netflix</span><br><span class="line">通信方式：http restful</span><br><span class="line">注册中心：eureka，consul，nacos</span><br><span class="line">配置中心：config</span><br><span class="line">断路器：hystrix</span><br><span class="line">网关：zuul，gateway</span><br><span class="line">分布式追踪系统：sleuth+zipkin</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>差别</p><table><thead><tr><th></th><th><strong>dubbo</strong></th><th><strong>spring cloud</strong></th><th></th></tr></thead><tbody><tr><td>背景</td><td>国内影响大</td><td>国外影响大</td><td>平手</td></tr><tr><td>社区活跃度</td><td>低(现在又好了)</td><td>高</td><td>cloud胜出</td></tr><tr><td>架构完整度</td><td>不完善（dubbo有些不提供，需要用第三方，它只关注服务治理）</td><td>比较完善，微服务组件应有尽有。</td><td>cloud胜出</td></tr><tr><td>学习成本</td><td>dubbo需要配套学习</td><td>无缝spring</td><td>cloud胜出</td></tr><tr><td>性能</td><td>高。（基于Netty）</td><td>低。（基于http，每次都要创建）。 此性能的损耗对大部分应用是可以接受的。而HTTP风格的API,是很方便的。用小的性能损耗换来了方便。</td><td>dubbo胜出</td></tr></tbody></table></li></ol><h2 id="Spring-Cloud-1"><a href="#Spring-Cloud-1" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>Spring Cloud是实现微服务架构的一系列框架的有机集合。</p><p>是在Spring Boot基础上构建的，用于简化分布式系统构建的工具集。是拥有众多子项目的项目集合。利用Spring Boot的开发便利性，巧妙地简化了分布式系统基础设施（服务注册与发现、熔断机制、网关路由、配置中心、消息总线、负载均衡、链路追踪等）的开发。</p><h3 id="版本演进"><a href="#版本演进" class="headerlink" title="版本演进"></a>版本演进</h3><ol><li><p>版本过程：版本名.版本号。</p></li><li><p>版本名：伦敦地铁字母顺序。</p></li><li><p>版本号：M（milestone）：里程碑，</p><p>​SR（Service Releases）：稳定版，</p><p>​RC(Release Candidate)：稳定版的候选版，也就是稳定版的最后一个版本。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">看官网：查询每个cloud版本下面的子模块的版本。</span><br><span class="line">https://spring.io/projects/spring-cloud</span><br><span class="line">此网页的最下面，目前最新的SpringCloud最新版本是：Greenwich.SR2</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">版本记录</span><br><span class="line">https://github.com/spring-cloud/spring-cloud-release/releases</span><br></pre></td></tr></table></figure><h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><blockquote><p>《Spring Cloud整体架构图》</p></blockquote><p>组成：</p><ol><li><p>服务注册与发现组件：Eureka，Zookeeper，Consul,Nacos等。Eureka基于REST风格的。</p></li><li><p>服务调用组件：Hystrix(熔断降级，在出现依赖服务失效的情况下，通过隔离 系统依赖服务  的方式，防止服务级联失败，同时提供失败回滚机制，使系统能够更快地从异常中恢复)，Ribbon（客户端负载均衡，用于提供客户端的软件负载均衡算法，提供了一系列完善的配置项：连接超时、重试等），OpenFeign（优雅的封装Ribbon，是一个声明式RESTful网络请求客户端，它使编写Web服务客户端变得更加方便和快捷）。</p></li><li><p>网关：路由和过滤。Zuul，Gateway。</p></li><li><p>配置中心：提供了配置集中管理，动态刷新配置的功能；配置通过Git或者其他方式来存储。</p></li><li><p>消息组件：Spring Cloud Stream（对分布式消息进行抽象，包括发布订阅、分组消费等功能，实现了微服务之间的异步通信）和Spring Cloud Bus（主要提供服务间的事件通信，如刷新配置）</p></li><li><p>安全控制组件：Spring Cloud Security 基于OAuth2.0开放网络的安全标准，提供了单点登录、资源授权和令牌管理等功能。</p></li><li><p>链路追踪组件：Spring Cloud Sleuth（收集调用链路上的数据），Zipkin（对Sleuth收集的信息，进行存储，统计，展示）。</p><p>每个点中的内容，后面都会讲到。</p></li></ol><h2 id="独立微服务编写"><a href="#独立微服务编写" class="headerlink" title="独立微服务编写"></a>独立微服务编写</h2><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>STS</p><p><a href="https://spring.io/tools">https://spring.io/tools</a></p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>通过这个服务来看eureka注册中心的效果。</p><p>复习Spring Boot。</p><p>减少了大量配置。快速开发。</p><p>用Starter集成一个新框架。比如redis，web等。添加依赖，加配置文件。</p><p>嵌入式服务器，令开发和部署变的方便。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Spring Boot介绍：</span><br><span class="line">https://docs.spring.io/spring-boot/docs/2.1.7.RELEASE/</span><br></pre></td></tr></table></figure><h3 id="代码步骤"><a href="#代码步骤" class="headerlink" title="代码步骤"></a>代码步骤</h3><ol><li>pom.xml</li><li>application.yml</li><li>java代码</li></ol><p>看代码。</p><h2 id="服务注册与发现"><a href="#服务注册与发现" class="headerlink" title="服务注册与发现"></a>服务注册与发现</h2><h3 id="Eureka-单节点搭建"><a href="#Eureka-单节点搭建" class="headerlink" title="Eureka 单节点搭建"></a>Eureka 单节点搭建</h3><ol><li><p>pom.xml</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">有的教程中还引入spring-boot-starter-web，其实不用。因为上面的依赖已经包含了它。在pom中点此依赖进去，一共点4次spring-cloud-netflix-eureka-server，发现web的依赖。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>application.yml</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">eureka: </span><br><span class="line">  client:</span><br><span class="line">    <span class="comment">#是否将自己注册到Eureka Server,默认为true，由于当前就是server，故而设置成false，表明该服务不会向eureka注册自己的信息</span></span><br><span class="line">    register-with-eureka: <span class="literal">false</span></span><br><span class="line">    <span class="comment">#是否从eureka server获取注册信息，由于单节点，不需要同步其他节点数据，用false</span></span><br><span class="line">    fetch-registry: <span class="literal">false</span></span><br><span class="line">    <span class="comment">#设置服务注册中心的URL，用于client和server端交流</span></span><br><span class="line">    service-url:                      </span><br><span class="line">      defaultZone: http://localhost:7900/eureka/</span><br></pre></td></tr></table></figure></li><li><p>application.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#是否将自己注册到Eureka Server,默认为true，由于当前就是server，故而设置成false，表明该服务不会向eureka注册自己的信息</span></span><br><span class="line"><span class="attr">eureka.client.register-with-eureka</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#是否从eureka server获取注册信息，由于单节点，不需要同步其他节点数据，用false</span></span><br><span class="line"><span class="attr">eureka.client.fetch-registry</span>=<span class="string">false</span></span><br><span class="line"><span class="comment">#设置服务注册中心的URL，用于client和server端交流</span></span><br><span class="line"><span class="attr">eureka.client.service-url.defaultZone</span>=<span class="string">http://localhost:7900/eureka/</span></span><br></pre></td></tr></table></figure></li><li><p>代码</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动类上添加此注解标识该服务为配置中心</span><br><span class="line">@EnableEurekaServer</span><br></pre></td></tr></table></figure></li><li><p>PS：Eureka会暴露一些端点。端点用于Eureka Client注册自身，获取注册表，发送心跳。</p></li><li><p>简单看一下eureka server控制台，实例信息区，运行环境信息区，Eureka Server自身信息区。</p></li></ol><h3 id="Eureka-介绍"><a href="#Eureka-介绍" class="headerlink" title="Eureka 介绍"></a>Eureka 介绍</h3><h4 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h4><ol><li>背景：在传统应用中，组件之间的调用，通过有规范的约束的接口来实现，从而实现不同模块间良好的协作。但是被拆分成微服务后，每个微服务实例的网络地址都可能动态变化，数量也会变化，使得原来硬编码的地址失去了作用。需要一个中心化的组件来进行服务的登记和管理。</li><li>概念：实现服务治理，即管理所有的服务信息和状态。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注册中心相当于买票乘车，只看有没有票（有没有服务），有就去买票（获取注册列表），然后乘车（调用）。不必关心有多少火车在运行。</span><br></pre></td></tr></table></figure><ol start="3"><li><p>注册中心好处：不用关心有多少提供方。</p></li><li><p>注册中心有哪些:Eureka，Nacos，Consul，Zookeeper等。</p></li><li><p>服务注册与发现包括两部分，一个是服务器端，另一个是客户端。</p><p>Server是一个公共服务，为Client提供服务注册和发现的功能，维护注册到自身的Client的相关信息，同时提供接口给Client获取注册表中其他服务的信息，使得动态变化的Client能够进行服务间的相互调用。</p><p>Client将自己的服务信息通过一定的方式登记到Server上，并在正常范围内维护自己信息一致性，方便其他服务发现自己，同时可以通过Server获取到自己依赖的其他服务信息，完成服务调用，还内置了负载均衡器，用来进行基本的负载均衡。</p></li><li><p>我们课程的Spring Cloud是用Eureka作为服务注册中心。</p></li><li><p>Eureka：是一个RESTful风格的服务，是一个用于服务发现和注册的基础组件，是搭建Spring Cloud微服务的前提之一，它屏蔽了Server和client的交互细节，使得开发者将精力放到业务上。</p></li><li><p>serverA从serverB同步信息，则serverB是serverA的peer。</p></li><li><p>上面例子中如果service-url为空，且register-with-eureka，fetch-registry为true，则会报错，Cannot execute request on any known server，因为server同时也是一个client，他会尝试注册自己，所以要有一个注册中心url去注册。</p></li><li><p>Netflix开源的组件。包括server和client两部分。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/Netflix/Eureka</span><br></pre></td></tr></table></figure></li></ol><h4 id="注册中心和微服务间的关系"><a href="#注册中心和微服务间的关系" class="headerlink" title="注册中心和微服务间的关系"></a>注册中心和微服务间的关系</h4><blockquote><p>《服务注册与发现关系图》</p></blockquote><h4 id="client功能"><a href="#client功能" class="headerlink" title="client功能"></a>client功能</h4><ol><li>注册：每个微服务启动时，将自己的网络地址等信息注册到注册中心，注册中心会存储（内存中）这些信息。</li><li>获取服务注册表：服务消费者从注册中心，查询服务提供者的网络地址，并使用该地址调用服务提供者，为了避免每次都查注册表信息，所以client会定时去server拉取注册表信息到缓存到client本地。</li><li>心跳：各个微服务与注册中心通过某种机制（心跳）通信，若注册中心长时间和服务间没有通信，就会注销该实例。</li><li>调用：实际的服务调用，通过注册表，解析服务名和具体地址的对应关系，找到具体服务的地址，进行实际调用。</li></ol><h4 id="server注册中心功能"><a href="#server注册中心功能" class="headerlink" title="server注册中心功能"></a>server注册中心功能</h4><ol><li><p>服务注册表：记录各个微服务信息，例如服务名称，ip，端口等。</p><p>注册表提供 查询API（查询可用的微服务实例）和管理API（用于服务的注册和注销）。</p></li><li><p>服务注册与发现：注册：将微服务信息注册到注册中心。发现：查询可用微服务列表及其网络地址。</p></li><li><p>服务检查：定时检测已注册的服务，如发现某实例长时间无法访问，就从注册表中移除。</p></li></ol><p>组件：Eureka , Consul , ZooKeeper，nacos等。</p><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>例子：api-listen-order</p><ol><li>pom.xml</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>application.yml</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#注册中心</span></span><br><span class="line">eureka: </span><br><span class="line">  client:</span><br><span class="line">    <span class="comment">#设置服务注册中心的URL</span></span><br><span class="line">    service-url:                      </span><br><span class="line">      defaultZone: http://root:root@localhost:7900/eureka/</span><br></pre></td></tr></table></figure><p>ps:不想注册，设置成false即可，实例演示结果：注册中心没有实例信息。找控制台204信息也没有找到。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring: </span><br><span class="line">  cloud:</span><br><span class="line">    service-registry:</span><br><span class="line">      auto-registration:</span><br><span class="line">        enabled: <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>注册成功：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DiscoveryClient_API-LISTEN-ORDER/api-listen-order:30.136.133.9:port - registration status: 204</span><br></pre></td></tr></table></figure><p>后面源码讲手动注册。</p><p>PS:</p><p>Eureka Server与Eureka Client之间的联系主要通过心跳的方式实现。心跳(Heartbeat)即Eureka Client定时向Eureka Server汇报本服务实例当前的状态，维护本服务实例在注册表中租约的有效性。</p><p>Eureka Client将定时从Eureka Server中拉取注册表中的信息，并将这些信息缓存到本地，用于服务发现。</p><h3 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h3><h3 id="Eureka高可用"><a href="#Eureka高可用" class="headerlink" title="Eureka高可用"></a>Eureka高可用</h3><p>高可用：可以通过运行多个Eureka server实例并相互注册的方式实现。Server节点之间会彼此增量地同步信息，从而确保节点中数据一致。</p><h4 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h4><h5 id="1-准备"><a href="#1-准备" class="headerlink" title="1.准备"></a>1.准备</h5><p>准备2个节点部署eureka，也可以单机部署</p><p>修改本机host文件，绑定一个主机名，单机部署时使用ip地址会有问题</p><h5 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.配置文件"></a>2.配置文件</h5><p><strong>节点 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#是否将自己注册到其他Eureka Server,默认为true 需要</span><br><span class="line">eureka.client.register-with-eureka=true</span><br><span class="line">#是否从eureka server获取注册信息， 需要</span><br><span class="line">eureka.client.fetch-registry=true</span><br><span class="line">#设置服务注册中心的URL，用于client和server端交流</span><br><span class="line">#此节点应向其他节点发起请求</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://ek2.com:7902/eureka/</span><br><span class="line">#主机名，必填</span><br><span class="line">eureka.instance.hostname=ek1.com</span><br><span class="line">management.endpoint.shutdown.enabled=true</span><br><span class="line">#web端口，服务是由这个端口处理rest请求的</span><br><span class="line">server.port=7901</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>节点 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#是否将自己注册到其他Eureka Server,默认为true 需要</span><br><span class="line">eureka.client.register-with-eureka=true</span><br><span class="line">#是否从eureka server获取注册信息， 需要</span><br><span class="line">eureka.client.fetch-registry=true</span><br><span class="line">#设置服务注册中心的URL，用于client和server端交流</span><br><span class="line">#此节点应向其他节点发起请求</span><br><span class="line">eureka.client.serviceUrl.defaultZone=http://ek1.com:7902/eureka/</span><br><span class="line">#主机名，必填</span><br><span class="line">eureka.instance.hostname=ek2.com</span><br><span class="line">management.endpoint.shutdown.enabled=true</span><br><span class="line">#web端口，服务是由这个端口处理rest请求的</span><br><span class="line">server.port=7902</span><br></pre></td></tr></table></figure><p><strong>节点 1:</strong></p><p>如果有节点3，配置同上 改一下主机名和端口</p><p>略。。。</p><p>两个节点的话，如下图内容 就算成功了</p><p><img src="/images/image-20200403193147121.png" alt="image-20200403193147121"></p><h2 id="使用Spring-Boot2-x-Actuator监控应用"><a href="#使用Spring-Boot2-x-Actuator监控应用" class="headerlink" title="使用Spring Boot2.x Actuator监控应用"></a>使用Spring Boot2.x Actuator监控应用</h2><h3 id="开启监控"><a href="#开启监控" class="headerlink" title="开启监控"></a>开启监控</h3>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="默认端点"><a href="#默认端点" class="headerlink" title="默认端点"></a>默认端点</h3><p>Spring Boot 2.0 的Actuator只暴露了health和info端点，提供的监控信息无法满足我们的需求</p><p>在1.x中有n多可供我们监控的节点，官方的回答是为了安全….</p><h3 id="开启所有端点"><a href="#开启所有端点" class="headerlink" title="开启所有端点"></a>开启所有端点</h3><p>在application.yml中加入如下配置信息</p><p>*代表所有节点都加载</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启所有端点</span></span><br><span class="line"><span class="attr">management.endpoints.web.exposure.include</span>=<span class="string">*</span></span><br></pre></td></tr></table></figure><p>所有端点都开启后的api列表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;_links&quot;:&#123;&quot;self&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator&quot;,&quot;templated&quot;:false&#125;,&quot;archaius&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/archaius&quot;,&quot;templated&quot;:false&#125;,&quot;beans&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/beans&quot;,&quot;templated&quot;:false&#125;,&quot;caches-cache&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/caches/&#123;cache&#125;&quot;,&quot;templated&quot;:true&#125;,&quot;caches&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/caches&quot;,&quot;templated&quot;:false&#125;,&quot;health&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/health&quot;,&quot;templated&quot;:false&#125;,&quot;health-path&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/health/&#123;*path&#125;&quot;,&quot;templated&quot;:true&#125;,&quot;info&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/info&quot;,&quot;templated&quot;:false&#125;,&quot;conditions&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/conditions&quot;,&quot;templated&quot;:false&#125;,&quot;configprops&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/configprops&quot;,&quot;templated&quot;:false&#125;,&quot;env&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/env&quot;,&quot;templated&quot;:false&#125;,&quot;env-toMatch&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/env/&#123;toMatch&#125;&quot;,&quot;templated&quot;:true&#125;,&quot;loggers&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/loggers&quot;,&quot;templated&quot;:false&#125;,&quot;loggers-name&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/loggers/&#123;name&#125;&quot;,&quot;templated&quot;:true&#125;,&quot;heapdump&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/heapdump&quot;,&quot;templated&quot;:false&#125;,&quot;threaddump&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/threaddump&quot;,&quot;templated&quot;:false&#125;,&quot;metrics&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/metrics&quot;,&quot;templated&quot;:false&#125;,&quot;metrics-requiredMetricName&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/metrics/&#123;requiredMetricName&#125;&quot;,&quot;templated&quot;:true&#125;,&quot;scheduledtasks&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/scheduledtasks&quot;,&quot;templated&quot;:false&#125;,&quot;mappings&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/mappings&quot;,&quot;templated&quot;:false&#125;,&quot;refresh&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/refresh&quot;,&quot;templated&quot;:false&#125;,&quot;features&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/features&quot;,&quot;templated&quot;:false&#125;,&quot;service-registry&quot;:&#123;&quot;href&quot;:&quot;http://localhost:8080/actuator/service-registry&quot;,&quot;templated&quot;:false&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="api端点功能"><a href="#api端点功能" class="headerlink" title="api端点功能"></a>api端点功能</h3><h4 id="Health"><a href="#Health" class="headerlink" title="Health"></a>Health</h4><p>会显示系统状态</p><p>{“status”:”UP”}</p><h4 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h4><p>用来关闭节点</p><p>开启远程关闭功能</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">management.endpoint.shutdown.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><p>使用Post方式请求端点</p><p>{</p><p>  “message”: “Shutting down, bye…”</p><p>}</p><p> autoconfig </p><p>获取应用的自动化配置报告<br> beans </p><p>获取应用上下文中创建的所有Bean </p><h4 id="configprops"><a href="#configprops" class="headerlink" title="configprops"></a>configprops</h4><p>获取应用中配置的属性信息报告 </p><h4 id="env"><a href="#env" class="headerlink" title="env"></a>env</h4><p>获取应用所有可用的环境属性报告 </p><h4 id="Mappings"><a href="#Mappings" class="headerlink" title="Mappings"></a>Mappings</h4><p> 获取应用所有Spring Web的控制器映射关系报告</p><h4 id="info"><a href="#info" class="headerlink" title="info"></a>info</h4><p>获取应用自定义的信息 </p><h4 id="metrics"><a href="#metrics" class="headerlink" title="metrics"></a>metrics</h4><p>返回应用的各类重要度量指标信息 </p><p><strong>Metrics</strong>节点并没有返回全量信息，我们可以通过不同的<strong>key</strong>去加载我们想要的值</p><p> metrics&#x2F;jvm.memory.max</p><h3 id="Threaddump"><a href="#Threaddump" class="headerlink" title="Threaddump"></a>Threaddump</h3><p>1.x中为<strong>dump</strong></p><p>返回程序运行中的线程信息 </p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务设计</title>
      <link href="/post/28f05446.html"/>
      <url>/post/28f05446.html</url>
      
        <content type="html"><![CDATA[<h1 id="微服务设计原则"><a href="#微服务设计原则" class="headerlink" title="微服务设计原则"></a>微服务设计原则</h1><p>架构，模式，拆分，隔离。目标：<strong>隔离系统的变化点</strong>。</p><h2 id="具体原则："><a href="#具体原则：" class="headerlink" title="具体原则："></a>具体原则：</h2><p>高内聚，低耦合。</p><p>高度自治：开发，测试，构建，部署，运行，发布。（无状态）</p><p>以业务为中心。</p><p>弹性设计。（容错，隔离，降级）。</p><p>自动化。持续集成，持续交付。</p><p>粒度把控：没有标准。任何一个服务，不要因为自己的开发和维护，影响其他服务。</p><p>api组，service组。</p><p>业务层，能力层。</p><h2 id="AKF："><a href="#AKF：" class="headerlink" title="AKF："></a>AKF：</h2><p>x轴：水平复制。A  A  A   A   A。</p><p>y轴：A </p><p>z轴：数据分片：手机，衣服，家电。； 杭州，北京。盘古。</p><hr><h1 id="基础业务架构图"><a href="#基础业务架构图" class="headerlink" title="基础业务架构图"></a>基础业务架构图</h1><p><img src="/img/3-%E5%9F%BA%E7%A1%80%E4%B8%9A%E5%8A%A1%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="image"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈CAP</title>
      <link href="/post/d9f5e25f.html"/>
      <url>/post/d9f5e25f.html</url>
      
        <content type="html"><![CDATA[<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="order-订单服务"><a href="#order-订单服务" class="headerlink" title="order 订单服务"></a>order 订单服务</h3><p><a href="http://10.0.4.52:7078/swagger/index.html">http://10.0.4.52:7078/swagger/index.html</a> </p><h3 id="stock-库存服务"><a href="#stock-库存服务" class="headerlink" title="stock 库存服务"></a>stock 库存服务</h3><p><a href="http://10.0.4.52:7077/swagger/index.html">http://10.0.4.52:7077/swagger/index.html</a> </p><p>对于分布式事务，常用的解决方案根据一致性的程度可以进行如下划分：</p><p>强一致性(2PC、3PC)：数据库层面的实现，通过锁定资源，牺牲可用性，保证数据的强一致性，效率相对比较低。</p><p>弱一致性(TCC)：业务层面的实现，通过预留或锁定部分资源，最后通过确认或取消操作完成事务的处理。比如A向B转款500元，A账号会冻结500元，其他操作正常，B接收转款时，也不能直接入账，而是将500元放到预留空间，只有经过确认之后，A才正式扣钱，B才正式入账；如果取消把A的500块解冻，B也不会入账。</p><p>最终一致性(本地消息表)：不管经过多少个服务节点，最终数据一致就行。比如下单成功之后，需要库存服务扣减库存，如果库存扣减失败，不管是重试，还是最后人工处理，最后确保订单和库存数据能对上就行；为保证用户体验，及时通过中间状态的形式反馈给用户，比如常见的出票中、数据处理中等。</p><p>对于强一致性和弱一致性的解决方案一般针对数据一致性和时效性要求特别高的业务场景，通常会牺牲暂时的可用性来满足一致性的要求；由于为保证一致性，会锁定资源，在高并发的业务场景不是最佳选择，所以很多系统在业务需求允许的情况下，基本上都会采用最终一致性方案。</p><p><img src="/img/CAP01.png" alt="image"></p><ul><li>CAP 集在ASP.NET Core 微服务架构中的示意图</li></ul><h2 id="CAP：最终一致性，分布式事务解决方案。"><a href="#CAP：最终一致性，分布式事务解决方案。" class="headerlink" title="CAP：最终一致性，分布式事务解决方案。"></a>CAP：最终一致性，分布式事务解决方案。</h2><p>顾名思义就是保证数据最后的一致性就行了。如果中间节点发生失败，系统为了减少代价，一般不会自动回滚，而是通过重试机制和人工参与的方式对失败数据进行处理，从而保证系统高并发场景下高可用的数据一致性需求。</p><p>CAP 是一个EventBus(事件总线)，同时也是一个在微服务或者SOA系统中解决分布式事务问题的一个框架，基于CAP理论思想进行封装的。采用模块化设计，具有高度的可扩展性，可靠并且易于更改。<br>对于分布式事务的处理，CAP 框架采用的是“异步确保”这种方案，即本地消息表。官方支持的数据存储方式有SQL Server、MySQL、PostgreSql、MongoDB、In-Memory(内存)，由于是开源项目，社区大佬也提供了其他数据存储支持，如：Oracle、SQLite、SmartSql等。<br>在分布式系统，各节点需要进行消息传输，CAP框架提供以下几种方式RabbitMQ、Kafka、Redis Streams(Redis 5.0支持)、Azure Service Bus、Amazon SQS、In-Memory Queue，使用方式都差不多。<br>本地消息表：就是在对应业务数据库中增加的一张消息表；这张表存储业务产生的消息，通过本地事务保证业务数据和消息数据的一致性。在消息表中通过一个状态来标识业务是否执行成功，如果失败，后台任务就进行重试。</p><p>上图简要说明：<br>有两个微服务，服务A和服务B；<br>服务A中通过本地事务的方式，将事件消息和业务逻辑进行事务保存(事件消息保存在本地消息表中)，保证业务逻辑和消息的一致性和可靠性；关于消息的处理和保存CAP已经封装在内部；<br>CAP内部定时调度任务将消息发布到消息队列中；<br>服务B订阅到消息，将其保存到服务B的本地消息表中，CAP已经封装好，只需按照说明使用即可；<br>如果业务处理失败，服务B中集成的CAP会根据配置的定时任务策略进行重试，直到处理成功为止；<br>2.使用及配置说明<br>以订单服务为例：<br>首先nuget 添加 依赖包 如下：<br>DotNetCore.CAP<br>DotNetCore.CAP.Dashboard<br>DotNetCore.CAP.MySql<br>DotNetCore.CAP.RabbitMQ</p><p>然后在Startup -》ConfigureServices 注册<br><img src="/img/CAP03.png" alt="image"><br>配置作用见注释，CAP注册完毕。</p><p>业务使用代码：<br>1.跨服务一致性，以购买商品为例，新增订单（订单服务）-&gt;库存减少（库存服务）<br>订单服务：<br><img src="/img/CAP04.png" alt="image"></p><p>&lt;1&gt;.加事务的代码一般写在仓储封层，orderEntity在上面有定义图没有截全。<br>&lt;2&gt;.业务代码可以写在 _capBus.Publish 之前或之后，但一定要写在Commit 前。<br>&lt;3&gt;.使用try-catch的话一定要加Rollback 回滚。<br>&lt;4&gt;.try-catch 异常不能吞掉，一定要抛出来。</p><p>库存服务<br><img src="/img/CAP05.png" alt="image"></p><p>&lt;1&gt;.订阅一般写在Controller，可以订阅多个。<br>&lt;2&gt;.NonAction 不被识别为接口<br>&lt;3&gt;.可以继续向下发布流程，比如库存扣减成功，下一步到物流服务进行相关处理，可以继续发布消息</p><p>2.单服务一致性：新增订单报错（订单服务）<br><img src="/img/CAP06.png" alt="image"></p><p>&lt;1&gt;.Commit 提交以后sql语句才会被执行。<br>&lt;2&gt;.如果B服务需要查询A服务的新增数据，建议手动提交，不使用自动提交。</p><p>3.应用场景问题</p><p>&lt;1&gt;.人工怎么快速介入</p><p>文献：<br><a href="https://github.com/dotnetcore/CAP/blob/master/README.zh-cn.md">https://github.com/dotnetcore/CAP/blob/master/README.zh-cn.md</a> （官方）<br><a href="https://cap.dotnetcore.xyz/user-guide/zh/getting-started/quick-start/">https://cap.dotnetcore.xyz/user-guide/zh/getting-started/quick-start/</a><br><a href="https://www.cnblogs.com/savorboard/p/cap-document.html">https://www.cnblogs.com/savorboard/p/cap-document.html</a><br><a href="https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html">https://www.cnblogs.com/savorboard/p/distributed-system-transaction-consistency.html</a> (分布事务理论支持，强烈推荐)</p>]]></content>
      
      
      
        <tags>
            
            <tag> CAP、Net </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker实战常用命令</title>
      <link href="/post/f5b22281.html"/>
      <url>/post/f5b22281.html</url>
      
        <content type="html"><![CDATA[<h3 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h3><ul><li>安装需要的软件包</li><li>yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><ul><li>设置Docker yum源</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><ul><li>查看所有仓库中所有docker版本 可以查看所有仓库中所有docker版本,并选择特定的版本安装</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | <span class="built_in">sort</span> -r</span><br></pre></td></tr></table></figure><ul><li>安装docker</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure><p>由于repo中默认只开启stable仓库，故这里安装的是最新稳18.03.0.ce-1.el7.centos。<br>如果要安装特定版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce-18.06.1.ce  </span><br></pre></td></tr></table></figure><h3 id="设置为开机启动"><a href="#设置为开机启动" class="headerlink" title="设置为开机启动"></a>设置为开机启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="查看启动状态"><a href="#查看启动状态" class="headerlink" title="查看启动状态"></a>查看启动状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h3 id="查看运行容器"><a href="#查看运行容器" class="headerlink" title="查看运行容器"></a>查看运行容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><h3 id="查看所有容器"><a href="#查看所有容器" class="headerlink" title="查看所有容器"></a>查看所有容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><h3 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop 容器ID</span><br></pre></td></tr></table></figure><h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器ID</span><br></pre></td></tr></table></figure><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 容器ID</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> 容器ID</span><br></pre></td></tr></table></figure><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f 容器ID</span><br></pre></td></tr></table></figure><p> </p><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi 镜像ID </span><br></pre></td></tr></table></figure><h3 id="镜像加速"><a href="#镜像加速" class="headerlink" title="镜像加速"></a>镜像加速</h3><p>sudo mkdir -p &#x2F;etc&#x2F;docker<br>sudo tee &#x2F;etc&#x2F;docker&#x2F;daemon.json &lt;&lt;-‘EOF’<br>{<br>  “registry-mirrors”: [“<a href="https://bpj58bpm.mirror.aliyuncs.com"]">https://bpj58bpm.mirror.aliyuncs.com&quot;]</a><br>}<br>EOF<br>sudo systemctl daemon-reload<br>sudo systemctl restart docker</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> cc.tect.ms:/app/Logs /tmp/Logs.bak</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it 容器ID /bin/bash </span><br></pre></td></tr></table></figure><p>docker logs –tail&#x3D;500 ccs.fat<br>sudo apt-get install vim<br> docker-compose up -d</p><p>重启网络<br>&#x2F;etc&#x2F;init.d&#x2F;network restart</p><p>启动docker：systemctl start docker<br>停止docker：systemctl stop docker<br>重启docker：systemctl restart docker<br>查看docker状态：systemctl status docker<br>开机启动：systemctl enable docker</p><p>Linux centos重启命令：<br>　　1、reboot   普通重启<br>　　2、shutdown -r now 立刻重启(root用户使用)<br>　　3、shutdown -r 10 过10分钟自动重启(root用户使用)<br>　　4、shutdown -r 20:35 在时间为20:35时候重启(root用户使用)<br>　　如果是通过shutdown命令设置重启的话，可以用shutdown -c命令取消重启<br>　Linux centos关机命令：<br>　　1、halt 立刻关机<br>　　2、poweroff 立刻关机<br>　　3、shutdown -h now 立刻关机(root用户使用)<br>　　4、shutdown -h 10 10分钟后自动关机<br>　　如果是通过shutdown命令设置关机的话，可以用shutdown -c命令取消重启</p><p>1、firewalld的基本使用<br>启动： systemctl start firewalld<br>关闭： systemctl stop firewalld<br>查看状态： systemctl status firewalld <br>开机禁用  ： systemctl disable firewalld<br>开机启用  ： systemctl enable firewalld</p><p>systemctl start docker<br>–selinux-enabled<br>&#x3D;false<br>“storage-driver”: “overlay2”,<br>“storage-opts”: [ “overlay2.override_kernel_check&#x3D;true” ]</p><p>docker info | grep “Docker Root Dir”<br>{<br>  “storage-driver”: “overlay2”,<br>  “storage-opts”: [<br>    “overlay2.override_kernel_check&#x3D;true”<br>  ]<br>}<br>rm -rf &#x2F;var&#x2F;lib&#x2F;docker<br>ln -s &#x2F;home&#x2F;docker &#x2F;var&#x2F;lib&#x2F;docker<br>history</p><h3 id="常用中间件"><a href="#常用中间件" class="headerlink" title="常用中间件"></a>常用中间件</h3><p>&#x2F;&#x2F;创建Docker镜像<br>进入发布文件夹<br>镜像名要全小写<br>docker build -t zaaby-message-bus-rabbitmq-provider-demo .<br>docker run -d –restart always -p 5001:80 –name zaaby-rabbitmq-demo zaaby-message-bus-rabbitmq-provider-demo<br>morunchang&#x2F;fastdfs<br>docker run -d –restart always –name tracker –net&#x3D;host morunchang&#x2F;fastdfs sh tracker.sh<br>docker run -d –restart always –name storage –net&#x3D;host -e TRACKER_IP&#x3D;192.168.78.152:22122 -e GROUP_NAME&#x3D;group1 morunchang&#x2F;fastdfs sh storage.sh<br>&#x2F;&#x2F;进入容器<br>docker exec -it 519d5ef67cad &#x2F;bin&#x2F;bash<br>&#x2F;&#x2F;文件保存地址<br>&#x2F;data&#x2F;fast_data&#x2F;data<br>season&#x2F;fastdfs<br>docker run -ti -d –name trakcer -v ~&#x2F;tracker_data:&#x2F;fastdfs&#x2F;tracker&#x2F;data –net&#x3D;host season&#x2F;fastdfs tracker<br>docker run -ti -d –name storage -v ~&#x2F;storage_data:&#x2F;fastdfs&#x2F;storage&#x2F;data -v ~&#x2F;store_path:&#x2F;fastdfs&#x2F;store_path –net&#x3D;host -e TRACKER_SERVER:127.0.0.1:22122 season&#x2F;fastdfs storage<br>docker run -ti -d –name fdfs_sh –net&#x3D;host season&#x2F;fastdfs sh<br>influxdb<br>docker run -d –restart always -p 8086:8086 -p 2003:2003 -p 8083:8083 -e INFLUXDB_ADMIN_ENABLED&#x3D;true –name influxdb_test influxdb<br>&#x2F;&#x2F;创建数据库<br>curl <a href="http://localhost:8086/query">http://localhost:8086/query</a> –data-urlencode “q&#x3D;CREATE DATABASE appmetricsapi”                                                                                                                                                                                                                                                                      <br>grafana<br>docker run -d –restart always -p 3000:3000 –name grafana grafana&#x2F;grafana<br>docker exec -it 4184f6af3360 &#x2F;bin&#x2F;bash<br>&#x2F;&#x2F;安装zabbix插件命令<br>grafana-cli plugins install alexanderzobnin-zabbix-app<br>rabbitmq<br>docker run -d –restart always –hostname my-rabbit –name test-rabbitmq -p 4369:4369 -p 5671:5671 -p 5672:5672 -p 15672:15672 -p 25672:25672 -p 15671:15671 -e RABBITMQ_ERLANG_COOKIE&#x3D;’secret cookie here’ rabbitmq:3-management<br>guest:guest<br>mysql<br>docker run -d –restart always -p 3306:3306 –name test-mysql -e MYSQL_ROOT_PASSWORD&#x3D;123qweasd,.&#x2F; mysql:latest<br>root:123qweasd,.&#x2F;</p><p>docker run -p 13306:3306 –name mysql -v &#x2F;data&#x2F;mysql&#x2F;conf:&#x2F;etc&#x2F;mysql -v &#x2F;data&#x2F;mysql&#x2F;logs:&#x2F;logs -v &#x2F;data&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;123qweasd,.&#x2F; -d mysql:5.7</p><p>docker run -p 3306:3306 –name mysql -v &#x2F;data&#x2F;mysql&#x2F;conf&#x2F;my.cnf:&#x2F;etc&#x2F;mysql&#x2F;my.cnf -v &#x2F;data&#x2F;mysql&#x2F;logs:&#x2F;logs -v &#x2F;data&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql -e MYSQL_ROOT_PASSWORD&#x3D;123qweasd,.&#x2F; -d mysql:5.7</p><p>对于自建 MySQL , 需要先开启 Binlog 写入功能，配置 binlog-format 为 ROW 模式，my.cnf 中配置如下<br>[mysqld]<br>log-bin&#x3D;mysql-bin # 开启 binlog<br>binlog-format&#x3D;ROW # 选择 ROW 模式<br>server_id&#x3D;1 # 配置 MySQL replaction 需要定义，不要和 canal 的 slaveId 重复<br>注意：针对阿里云 RDS for MySQL , 默认打开了 binlog , 并且账号默认具有 binlog dump 权限 , 不需要任何权限或者 binlog 设置,可以直接跳过这一步<br>授权 canal 链接 MySQL 账号具有作为 MySQL slave 的权限, 如果已有账户可直接 grant<br>CREATE USER canal IDENTIFIED BY ‘canal’;  <br>GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT ON <em>.</em> TO ‘canal‘@’%’;<br>GRANT ALL PRIVILEGES ON <em>.</em> TO ‘canal‘@’%’ ;<br>FLUSH PRIVILEGES;</p><p>mongodb<br>docker run -d –restart always -p 27017:27017 –name test-mongo mongo<br>–Add the Initial Admin User<br>$ docker exec -it test-mongo mongo admin<br>db.createUser({ user: ‘aaa’, pwd: ‘123’, roles: [ { role: “userAdminAnyDatabase”, db: “admin” } ] });<br>redis<br>docker run –name redis -p 6379:6379 -d –restart&#x3D;always redis:latest redis-server –appendonly yes –requirepass “redis_dev_123456”</p><p>elasticsearch<br>docker run -e ES_JAVA_OPTS&#x3D;”-Xms512m -Xmx512m” -d –restart always -p 9200:9200 -p 9300:9300 –name test-elastic elasticsearch<br>无账号密码<br>postgresql<br>docker run -d –restart always -p 5432:5432 –name test-postgres -e POSTGRES_PASSWORD&#x3D;123qweasd,.&#x2F; postgres<br>postgres:123qweasd,.&#x2F;<br>consul<br>docker run -d –name&#x3D;dev-consul -p 8300:8300 -p 8301:8301 -p 8302:8302 -p 8500:8500 -p 8600:8600 -e CONSUL_BIND_INTERFACE&#x3D;eth0 consul<br>docker run -d -e CONSUL_BIND_INTERFACE&#x3D;eth0 consul agent -dev -join&#x3D;192.168.78.152<br>展示环境中间件<br>mongodb<br>192.168.5.229:27017 无账号密码<br>mysql<br>192.168.5.229 root:123qweasd,.&#x2F;<br>rabbitmq<br>192.168.5.229 guest:guest<br>redis<br>192.168.5.55:6379 无账号密码<br>elasticsearch<br>192.168.5.229:9200 无账号密码<br>开发环境<br>rabbitmq<br>192.168.5.56:5672 无账号密码<br>管理页面<br>192.168.5.56:15672 guest:guest<br>mysql<br>192.168.5.56:3306 root:123456<br>mongo<br>192.168.5.56:27017 rootadmin:123456<br>redis<br>192.168.5.56 无账号密码<br>elasticsearch<br>192.168.5.56:9200 无账号密码</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Net7</title>
      <link href="/post/undefined.html"/>
      <url>/post/undefined.html</url>
      
        <content type="html"><![CDATA[<h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">专业</span><br></pre></td></tr></table></figure><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p><img src="/img/net7-02.png" alt="image"><br><img src="/img/net7-xn.png" alt="image"><br><img src="/img/net7.png" alt="image"><br><img src="/img/net7-01.png" alt="image"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">专业</span><br></pre></td></tr></table></figure><!-- More info: [Writing](https://hexo.io/docs/writing.html) --><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">认真</span><br></pre></td></tr></table></figure><!-- More info: [Server](https://hexo.io/docs/server.html) --><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">耐心</span><br></pre></td></tr></table></figure><!-- More info: [Generating](https://hexo.io/docs/generating.html) --><h3 id="04"><a href="#04" class="headerlink" title="04"></a>04</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">温暖</span><br></pre></td></tr></table></figure><h3 id="图片我还有很多"><a href="#图片我还有很多" class="headerlink" title="图片我还有很多"></a>图片我还有很多</h3><p><img src="/img/net7-02.png" alt="image"><br><img src="/img/net7-xn.png" alt="image"><br><img src="/img/net7.png" alt="image"><br><img src="/img/net7-01.png" alt="image"><br><img src="/img/index-p.jpg" alt="image"><br><img src="/img/index-p2.jpg" alt="image"><br><img src="/img/index-p2.jpg" alt="image"></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
